This material aims to teach principles and understanding fundamental to the study of Computer Science, and programming in general.  It is intended to be used by an instructor in a hands-on and interactive setting, accesible to motivated beginners, but useful to those with programming experience.  It is not a tutorial or a getting started guide for a particular language, paradigm, or application, and instead covers general fundamentals.  It is also not exhaustive, and other course material may be created in the future for more in-depth studies of any or all of the topics covered by this material.

The philosophy of this material is that Computer Scientists need to have an understanding of both mathematical theory (the "top" or "high level") and inner machine workings (the "bottom" or "low level") and practical applications of both.

== Outline ==

=== Assembly ===

* Registers, instructions, and number systems
* Labels, branches, conditional execution, and procedures
* Interacting with RAM, The Stack, and saving registers
* Pointers, pointer arithmetic, and arrays
* Talking to hardware and bitmasks
* Recursion and tail-call elimination

=== Untyped Lambda Calculus ===

* ULC syntax, alpha equivalence, and Turing Completeness
* Beta reduction
* Normal form, reduction strategies, and the Halting Problem
* Boolean Algebra
* Church Numerals
* Fixed-point combinators

== C ==

* Procedures, recursion, and tail-call elimination
* Libraries, build systems, and the preprocessor
* Syscalls, Pointers, and RAM
* Structured Data and Pointer Arithmetic
* Singly and doubly linked lists, and trees
* Function Pointers, Iterators, and Binary Search
* Memory Management Techniques

== Haskell ==

* Names and pattern matching
* Modules and build systems
* Types
* Merge sort and runtime analysis
* Typeclasses, including Functor
* Applicative Functors and Monads
* Dynamic Typing

== Ruby ==

* Memoized Fibonacci
* Classes, Inheritance, and Encapsulation
* Duck Typing and Monkeypatching
* Mix-in Modules and Metaprogramming
